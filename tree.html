<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>树形结构可视化(调整文字框比例)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="./data.js"></script>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f7fa;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            width: 100%;
            height: 100vh;
            margin: 0;
            padding: 0;
            background: white;
            display: flex;
            flex-direction: column;
        }

        h1 {
            margin: 0;
            padding: 10px 20px;
            font-size: 1.5rem;
            border-bottom: 1px solid #eee;
        }

        #tree-container {
            flex: 1;
            width: 100%;
            overflow: hidden;
            background: white;
            position: relative;
        }

        .node rect {
            fill: #fff;
            stroke: #4a6fa5;
            stroke-width: 3px;
            rx: 8;
            ry: 8;
            transition: all 0.3s ease;
        }

        .node.selected rect {
            fill: #ffd700;
            stroke: #ff8c00;
            stroke-width: 4px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .node.selected text {
            font-weight: bold;
            fill: #333;
        }

        .node:hover:not(.selected) rect {
            fill: #e8f4f8;
            stroke: #2c5aa0;
            stroke-width: 3.5px;
            cursor: pointer;
        }

        /* 路径上的节点高亮样式 */
        .node.path-selected rect {
            fill: #fff4e6;
            stroke: #ff4500;
            stroke-width: 4px;
        }

        .node.path-hover rect {
            fill: #e6f7ff;
            stroke: #00bfff;
            stroke-width: 3.5px;
        }

        /* 叠加效果：同时有选中和悬浮路径高亮时 */
        .node.path-selected.path-hover rect {
            fill: #e6ffe6;
            stroke: #00cc00;
            stroke-width: 5px;
        }

        .node:hover:not(.selected) text {
            font-weight: 600;
        }

        .node.selected:hover rect {
            fill: #ffed4e;
            stroke: #ff7700;
            stroke-width: 4.5px;
            cursor: pointer;
        }

        .node text {
            font-weight: 500;
            text-anchor: middle;
            dominant-baseline: middle;
            /* 字体大小由JavaScript动态控制，根据节点深度缩放 */
        }

        .link {
            fill: none;
            stroke: #333;
            stroke-width: 2.5px;
            pointer-events: none;
            /* 确保连接线不阻挡鼠标事件 */
            opacity: 1 !important;
            /* 强制显示连接线 */
            transition: stroke 0.3s ease, stroke-width 0.3s ease;
        }

        .link.selected-highlight {
            stroke: #ff4500;
            stroke-width: 6px;
            opacity: 1 !important;
        }

        .link.hover-highlight {
            stroke: #00bfff;
            stroke-width: 5px;
            opacity: 1 !important;
        }

        /* 叠加效果：同时有选中和悬浮高亮时 */
        .link.selected-highlight.hover-highlight {
            stroke: #00cc00;
            stroke-width: 7px;
            opacity: 1 !important;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .btn {
            background: #4a6fa5;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>树形结构可视化(调整文字框比例)</h1>
        <div id="tree-container"></div>
    </div>

    <script>
        // 树形数据
        const treeData = data;

        // 计算树的最大深度
        function getMaxDepth(node, currentDepth = 0) {
            if (!node) return currentDepth;
            if (!node.children || node.children.length === 0) {
                return currentDepth;
            }
            let maxDepth = currentDepth;
            node.children.forEach(child => {
                const depth = getMaxDepth(child, currentDepth + 1);
                maxDepth = Math.max(maxDepth, depth);
            });
            return maxDepth;
        }

        // 计算树的最大宽度（估算每层的最大节点数）
        function getMaxWidth(node) {
            const levelCounts = {};

            function countNodes(n, depth = 0) {
                if (!levelCounts[depth]) {
                    levelCounts[depth] = 0;
                }
                levelCounts[depth]++;

                if (n.children) {
                    n.children.forEach(child => {
                        countNodes(child, depth + 1);
                    });
                }
            }

            countNodes(node);

            // 返回最大层级的节点数
            const counts = Object.values(levelCounts);
            return counts.length > 0 ? Math.max(...counts) : 1;
        }

        // 根据数据计算树的深度和宽度
        const maxDepth = getMaxDepth(treeData);
        const maxWidthNodes = getMaxWidth(treeData);

        // 设置尺寸和边距
        const margin = { top: 50, right: 120, bottom: 50, left: 120 };

        // 根据层数动态计算尺寸
        // 注意：D3 tree布局的size是[height, width]，其中height对应x坐标（垂直方向），width对应y坐标（水平方向）
        // 但y坐标是手动设置的，每层增加240像素

        // height: 用于D3 tree布局的x坐标范围（垂直方向），需要足够大以容纳所有节点
        // 根据最大节点数和节点宽度估算（每个节点约120像素宽，加上间距）
        const nodeWidth = 120;
        const nodeSpacing = 50; // 节点之间的间距
        const estimatedHeight = maxWidthNodes * (nodeWidth + nodeSpacing);
        const baseHeight = 1000; // 基础高度
        let height = Math.max(baseHeight, estimatedHeight);

        // width: 用于D3 tree布局的y坐标范围（水平方向），但y坐标是手动设置的
        // 根据y坐标间距计算（每层240像素）
        const fixedYSpacing = 120 * 2; // y坐标每层增加的固定值
        const baseWidth = 200; // 基础宽度
        let width = baseWidth + maxDepth * fixedYSpacing;

        // 创建SVG容器（初始尺寸，后续会根据实际图案大小更新）
        const svgElement = d3.select("#tree-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);

        const svg = svgElement
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // 初始化变换状态
        let currentTransform = d3.zoomIdentity;

        // 标记是否是首次加载（用于决定是否自动调整视图）
        let isFirstLoad = true;

        // 当前选中的节点
        let selectedNode = null;

        // 初始缩放比例设置（1.0 = 100%，0.5 = 50%，2.0 = 200%）
        // 如果设置为 null，则自动计算适合的缩放比例
        const initialScale = 0.5; // 设置为 null 自动计算，或设置为具体数值如 0.8, 1.0, 1.5 等

        // 创建zoom行为（需要在autoFitView之前定义）
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3]) // 启用缩放，允许0.1到3倍的缩放
            .filter(event => {
                // 对于wheel事件，只有在按住Ctrl/Cmd键时才允许zoom处理（缩放）
                // 否则阻止zoom处理，由自定义wheel处理器处理平移
                if (event.type === "wheel") {
                    return event.ctrlKey || event.metaKey;
                }
                return true; // 允许其他事件（鼠标拖拽、触摸等）
            })
            .on("zoom", (event) => {
                // 应用平移和缩放
                // 需要同时应用margin偏移和zoom的变换
                currentTransform = event.transform;
                // D3的zoom transform已经包含了scale，直接应用即可
                svg.attr("transform",
                    `translate(${margin.left + event.transform.x},${margin.top + event.transform.y}) scale(${event.transform.k})`);
            });

        // 计算节点缩放比例的辅助函数（根据深度）
        function getNodeScale(depth) {
            // 每级缩小15%，根节点为1.0，第一级为0.85，第二级为0.7225，以此类推
            const scaleFactor = 1;
            return Math.pow(scaleFactor, depth);
        }

        // 计算节点宽度的辅助函数（根据深度缩放）
        function getNodeWidth(d) {
            const baseWidth = 120; // Math.max(120, d.data.name.length * 12);
            const scale = getNodeScale(d.depth || 0);
            return baseWidth * scale;
        }

        // 计算节点高度的辅助函数（根据深度缩放）
        function getNodeHeight(depth = 0) {
            const baseHeight = 60;
            const scale = getNodeScale(depth);
            return baseHeight * scale;
        }

        // 计算节点字体大小的辅助函数（根据深度缩放）
        function getNodeFontSize(depth) {
            const baseFontSize = 14;
            const scale = getNodeScale(depth);
            return `${baseFontSize * scale}px`; // 返回带单位的字体大小
        }

        // 创建树布局（使用函数来动态获取尺寸）
        // 固定水平间距值（节点之间的最小距离）
        let treeLayout = d3.tree()
            .size([height, width])
        /*.separation((a, b) => {
            // 水平间距设置为两个节点中较大的宽度
            const widthA = getNodeWidth(a);
            const widthB = getNodeWidth(b);
            const spacing = Math.max(widthA, widthB); // 使用较大的节点宽度作为间距
            // 返回间距对应的比例值
            // 注意：D3 tree布局的size是[height, width]，所以这里需要根据实际宽度来调整
            // 使用一个较大的除数，让间距更紧凑
            return spacing / 200;
        });*/

        // 创建层级数据
        const root = d3.hierarchy(treeData);
        root.x0 = width / 2;
        root.y0 = 0;

        // 移动整个子树的辅助函数
        /*function shiftSubtree(node, shift) {
            if (node.children) {
                node.children.forEach(child => {
                    child.x += shift;
                    shiftSubtree(child, shift);
                });
            }
            if (node._children) {
                node._children.forEach(child => {
                    child.x += shift;
                    shiftSubtree(child, shift);
                });
            }
        }*/

        // 更新函数
        function update(source) {
            // 重新计算树布局（只考虑可见节点，折叠的节点会被自动排除）
            const treeData = treeLayout(root);

            // 获取所有可见节点（descendants会自动排除折叠的节点）
            const nodes = treeData.descendants();
            const links = treeData.links();

            // 如果是从根节点更新，重新初始化根节点位置
            if (source === root || source.depth === 0) {
                root.x0 = width / 2;
                root.y0 = 0;
            }

            // 只基于可见节点重新计算位置

            // 设置节点新位置（垂直方向间距，根据深度调整）
            // 计算每层的间距，考虑节点高度和缩放
            const baseNodeHeight = getNodeHeight(0);

            // D3 tree布局会自动计算x坐标（垂直位置），无需手动设置

            // 计算并设置每个节点的y坐标（水平位置）
            // y值以根节点的y为初值，根据层数依次增加固定值
            const rootNode = nodes.find(d => d.depth === 0);
            const rootY = rootNode ? rootNode.y : width / 2; // 根节点的y坐标作为初值
            const fixedYSpacing = 120; // y坐标每层增加的固定值

            nodes.forEach(d => {
                // y坐标 = 根节点的y + 层数 * 固定值
                d.y = rootY + d.depth * fixedYSpacing * 2;
            });

            // 调整节点位置以避免重叠（只调整可见节点）
            // adjustNodePositions函数内部会递归处理，只处理可见的子节点
            //adjustNodePositions(nodes);

            // 添加节点
            const node = svg.selectAll(".node")
                .data(nodes, d => d.id || (d.id = ++i));

            // 添加新节点
            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .on("click", click)
                .on("mouseover", function (event, d) {
                    // 鼠标悬浮时高亮路径（悬浮高亮，可以与选中高亮叠加）
                    highlightPathToRoot(d, false);
                })
                .on("mouseout", function (event, d) {
                    // 鼠标移开时，移除悬浮高亮，保留选中高亮
                    removeHoverHighlight();
                    // 如果有选中的节点，恢复选中节点的路径高亮
                    if (selectedNode) {
                        highlightPathToRoot(selectedNode, true);
                    }
                })
                .style("cursor", "pointer");

            // 添加长方形节点（根据深度缩放）
            nodeEnter.append("rect")
                .attr("width", d => getNodeWidth(d))
                .attr("height", d => getNodeHeight(d.depth))
                .attr("x", d => -getNodeWidth(d) / 2)
                .attr("y", d => -getNodeHeight(d.depth) / 2)
                .style("fill", d => {
                    if (d === selectedNode) return "#ffd700";
                    return d._children ? "lightsteelblue" : "#fff";
                })
                .style("stroke", d => d === selectedNode ? "#ff8c00" : "#4a6fa5")
                .style("stroke-width", d => d === selectedNode ? "4px" : "3px");

            // 添加节点文本（根据深度缩放字体）
            nodeEnter.append("text")
                .attr("dy", ".35em")
                .attr("font-size", d => getNodeFontSize(d.depth))
                .text(d => d.data.name);

            // 更新节点位置和尺寸
            const nodeUpdate = node.merge(nodeEnter);

            // 设置选中状态的class（在transition之前）
            nodeUpdate.classed("selected", d => d === selectedNode)
                .style("cursor", "pointer")
                .on("mouseover", function (event, d) {
                    // 鼠标悬浮时高亮路径（悬浮高亮，可以与选中高亮叠加）
                    highlightPathToRoot(d, false);
                })
                .on("mouseout", function (event, d) {
                    // 鼠标移开时，移除悬浮高亮，保留选中高亮
                    removeHoverHighlight();
                    // 如果有选中的节点，恢复选中节点的路径高亮
                    if (selectedNode) {
                        highlightPathToRoot(selectedNode, true);
                    }
                });

            // 应用位置变换动画
            nodeUpdate
                .transition()
                .duration(500)
                .attr("transform", d => `translate(${d.y},${d.x})`);

            // 更新节点矩形尺寸和样式
            nodeUpdate.select("rect")
                .transition()
                .duration(500)
                .attr("width", d => getNodeWidth(d))
                .attr("height", d => getNodeHeight(d.depth))
                .attr("x", d => -getNodeWidth(d) / 2)
                .attr("y", d => -getNodeHeight(d.depth) / 2)
                .style("fill", function (d) {
                    // 检查是否有路径高亮
                    const node = d3.select(this.parentNode);
                    if (node.classed("path-selected") && node.classed("path-hover")) {
                        return "#e6ffe6"; // 叠加效果（绿色）
                    }
                    if (node.classed("path-selected")) {
                        return "#fff4e6"; // 选中路径
                    }
                    if (node.classed("path-hover")) {
                        return "#e6f7ff"; // 悬浮路径
                    }
                    // 默认样式
                    if (d === selectedNode) return "#ffd700";
                    return d._children ? "lightsteelblue" : "#fff";
                })
                .style("stroke", function (d) {
                    const node = d3.select(this.parentNode);
                    if (node.classed("path-selected") && node.classed("path-hover")) {
                        return "#00cc00"; // 叠加效果（绿色）
                    }
                    if (node.classed("path-selected")) {
                        return "#ff4500"; // 选中路径
                    }
                    if (node.classed("path-hover")) {
                        return "#00bfff"; // 悬浮路径
                    }
                    // 默认样式
                    return d === selectedNode ? "#ff8c00" : "#4a6fa5";
                })
                .style("stroke-width", function (d) {
                    const node = d3.select(this.parentNode);
                    if (node.classed("path-selected") && node.classed("path-hover")) {
                        return "5px"; // 叠加效果
                    }
                    if (node.classed("path-selected")) {
                        return "4px"; // 选中路径
                    }
                    if (node.classed("path-hover")) {
                        return "3.5px"; // 悬浮路径
                    }
                    // 默认样式
                    return d === selectedNode ? "4px" : "3px";
                });

            // 更新节点文本字体大小
            nodeUpdate.select("text")
                .transition()
                .duration(500)
                .attr("font-size", d => getNodeFontSize(d.depth));

            // 移除退出节点
            const nodeExit = node.exit()
                .transition()
                .duration(500)
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .remove();

            // 添加连接线
            const link = svg.selectAll(".link")
                .data(links, d => d.target.id);

            // 创建折线连接器（Z形：先水平，再垂直，再水平）
            // 在D3 v7中，使用d3.line()来创建折线
            const line = d3.line()
                .curve(d3.curveStepAfter) // 使用折线
                .x(d => d[0])  // x坐标
                .y(d => d[1]); // y坐标

            // 创建Z型折线路径的函数
            const linkGenerator = (d) => {
                // 检查数据是否有效
                if (!d || !d.source || !d.target) {
                    return "M 0 0";
                }

                // 获取节点宽度
                const parentWidth = getNodeWidth(d.source);
                const parentHeight = getNodeHeight(d.source);
                const childWidth = getNodeWidth(d.target);

                // 计算起点：父节点右边中点
                // 注意：在垂直树中，x是垂直方向（上下），y是水平方向（左右）
                const startX = d.source.x;                    // 父节点垂直中心
                const startY = d.source.y + parentWidth / 2;  // 父节点右边

                // 计算终点：子节点左边中点
                const endX = d.target.x;                      // 子节点垂直中心
                const endY = d.target.y;     // 子节点左边

                // 计算中间转折点

                const midY = startY + parentWidth / 2;   // 水平方向的中间位置

                // Z型路径的4个点：起点 -> 水平移动 -> 垂直移动 -> 终点
                const points = [
                    [startY, startX],    // 1. 起点：父节点右边
                    [midY, startX],      // 2. 水平移动到中间（垂直位置不变）
                    [midY, endX],        // 3. 垂直移动到中间，水平移动到子节点位置
                    [endY, endX]         // 4. 终点：子节点左边
                ];
                return line(points);
            };

            // 添加新连接线（在节点之前插入，确保连接线在节点下方）
            const linkEnter = link.enter().insert("path", ".node")
                .attr("class", "link")
                .attr("d", d => {
                    // 初始状态：从源节点位置开始
                    const o = { x: source.x0, y: source.y0 };
                    return linkGenerator({ source: o, target: o });
                });

            // 更新连接线位置
            const linkUpdate = link.merge(linkEnter);
            linkUpdate
                .transition()
                .duration(500)
                .attr("d", d => linkGenerator(d));

            // 移除退出连接线
            link.exit()
                .transition()
                .duration(500)
                .remove();

            // 保存旧位置
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            // 更新SVG尺寸以适应所有节点
            updateSVGSize();

            // 如果有选中的节点，高亮其路径（选中高亮）
            if (selectedNode) {
                highlightPathToRoot(selectedNode, true);
            }
        }

        // 高亮从节点到根节点的路径（用于选中状态）
        function highlightPathToRoot(node, isSelected = true) {
            if (!node) return;

            // 找到从当前节点到根节点的所有连线和节点
            let currentNode = node;

            // 先高亮当前节点
            const currentNodeElement = svg.selectAll(".node")
                .filter(d => d === currentNode);

            if (currentNodeElement.size() > 0) {
                const rect = currentNodeElement.select("rect");
                if (isSelected) {
                    currentNodeElement.classed("path-selected", true);
                    // 直接设置样式，确保优先级
                    rect.style("fill", "#fff4e6")
                        .style("stroke", "#ff4500")
                        .style("stroke-width", "4px");
                } else {
                    currentNodeElement.classed("path-hover", true);
                    // 检查是否已有选中高亮
                    const hasSelected = currentNodeElement.classed("path-selected");
                    if (hasSelected) {
                        // 叠加效果（绿色）
                        rect.style("fill", "#e6ffe6")
                            .style("stroke", "#00cc00")
                            .style("stroke-width", "5px");
                    } else {
                        rect.style("fill", "#e6f7ff")
                            .style("stroke", "#00bfff")
                            .style("stroke-width", "3.5px");
                    }
                }
            }

            // 向上遍历到根节点
            while (currentNode && currentNode.parent) {
                // 高亮父节点
                const parentElement = svg.selectAll(".node")
                    .filter(d => d === currentNode.parent);

                if (parentElement.size() > 0) {
                    const rect = parentElement.select("rect");
                    if (isSelected) {
                        parentElement.classed("path-selected", true);
                        rect.style("fill", "#fff4e6")
                            .style("stroke", "#ff4500")
                            .style("stroke-width", "4px");
                    } else {
                        parentElement.classed("path-hover", true);
                        // 检查是否已有选中高亮
                        const hasSelected = parentElement.classed("path-selected");
                        if (hasSelected) {
                            // 叠加效果（绿色）
                            rect.style("fill", "#e6ffe6")
                                .style("stroke", "#00cc00")
                                .style("stroke-width", "5px");
                        } else {
                            rect.style("fill", "#e6f7ff")
                                .style("stroke", "#00bfff")
                                .style("stroke-width", "3.5px");
                        }
                    }
                }

                // 找到连接当前节点和父节点的连线
                const link = svg.selectAll(".link")
                    .filter(d => d.target === currentNode);

                if (link.size() > 0) {
                    if (isSelected) {
                        link.classed("selected-highlight", true);
                    } else {
                        link.classed("hover-highlight", true);
                    }
                }

                currentNode = currentNode.parent;
            }
        }

        // 移除选中高亮
        function removeSelectedHighlight() {
            svg.selectAll(".link").classed("selected-highlight", false);
            const nodes = svg.selectAll(".node.path-selected");
            nodes.classed("path-selected", false);
            // 恢复节点样式
            nodes.select("rect").each(function (d) {
                const rect = d3.select(this);
                const node = d3.select(this.parentNode);
                // 检查是否还有悬浮高亮
                if (node.classed("path-hover")) {
                    rect.style("fill", "#e6f7ff")
                        .style("stroke", "#00bfff")
                        .style("stroke-width", "3.5px");
                } else {
                    // 恢复默认样式
                    if (d === selectedNode) {
                        rect.style("fill", "#ffd700")
                            .style("stroke", "#ff8c00")
                            .style("stroke-width", "4px");
                    } else {
                        rect.style("fill", d._children ? "lightsteelblue" : "#fff")
                            .style("stroke", "#4a6fa5")
                            .style("stroke-width", "3px");
                    }
                }
            });
        }

        // 移除悬浮高亮
        function removeHoverHighlight() {
            svg.selectAll(".link").classed("hover-highlight", false);
            const nodes = svg.selectAll(".node.path-hover");
            nodes.classed("path-hover", false);
            // 恢复节点样式
            nodes.select("rect").each(function (d) {
                const rect = d3.select(this);
                const node = d3.select(this.parentNode);
                // 检查是否还有选中高亮
                if (node.classed("path-selected")) {
                    rect.style("fill", "#fff4e6")
                        .style("stroke", "#ff4500")
                        .style("stroke-width", "4px");
                } else {
                    // 恢复默认样式
                    if (d === selectedNode) {
                        rect.style("fill", "#ffd700")
                            .style("stroke", "#ff8c00")
                            .style("stroke-width", "4px");
                    } else {
                        rect.style("fill", d._children ? "lightsteelblue" : "#fff")
                            .style("stroke", "#4a6fa5")
                            .style("stroke-width", "3px");
                    }
                }
            });
        }

        // 移除所有高亮（兼容旧代码）
        function removeHighlight() {
            removeSelectedHighlight();
            removeHoverHighlight();
        }

        // 点击节点事件
        function click(event, d) {
            // 阻止事件冒泡，避免触发其他事件
            event.stopPropagation();

            // 切换选中状态
            if (selectedNode === d) {
                // 如果点击的是已选中的节点，取消选中
                selectedNode = null;
                removeSelectedHighlight(); // 取消选中时移除选中高亮
            } else {
                // 选中新节点
                selectedNode = d;
                highlightPathToRoot(d, true); // 选中时高亮路径（选中高亮）
            }

            // 处理折叠/展开
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            // 折叠/展开后，重新从根节点开始计算整个树的位置
            update(root);
        }

        // 初始化
        let i = 0;
        update(root);

        // 窗口大小改变时不再重新计算树布局，保持图案大小不变
        // 如果需要，可以只更新SVG容器的显示区域，但不改变树布局尺寸

        // 更新SVG尺寸以适应所有节点
        function updateSVGSize() {
            const nodes = treeLayout(root).descendants();
            if (nodes.length === 0) return;

            // 计算所有节点的边界（考虑margin偏移）
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            nodes.forEach(d => {
                const nodeWidth = getNodeWidth(d);
                const nodeHeight = getNodeHeight(d.depth);
                // 考虑margin偏移
                const actualX = d.x + margin.left;
                const actualY = d.y + margin.top;
                minX = Math.min(minX, actualX - nodeWidth / 2);
                maxX = Math.max(maxX, actualX + nodeWidth / 2);
                minY = Math.min(minY, actualY);
                maxY = Math.max(maxY, actualY + nodeHeight);
            });

            // 添加足够的边距，确保可以滑动到所有边界
            const padding = 100; // 减小边距，使图像更紧凑
            // 根据实际图案大小计算SVG尺寸，不受屏幕大小影响
            const newWidth = maxX - minX + padding * 2;
            const newHeight = maxY - minY + padding * 2;

            // 更新SVG尺寸
            svgElement
                .attr("width", newWidth)
                .attr("height", newHeight);

            // 只在首次加载时自动调整视图，折叠/展开时保持当前视野位置
            if (isFirstLoad) {
                autoFitView();
                isFirstLoad = false;
            } else {
                // 保持当前的transform，只更新SVG尺寸
                // 应用当前的transform，保持视野位置不变
                svg.attr("transform",
                    `translate(${margin.left + currentTransform.x},${margin.top + currentTransform.y}) scale(${currentTransform.k})`);
            }
        }

        // 自动调整视图，让图像居中并缩放到合适大小
        function autoFitView() {
            const nodes = treeLayout(root).descendants();
            if (nodes.length === 0) return;

            // 计算所有节点的边界（在SVG坐标系中，不考虑margin）
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            nodes.forEach(d => {
                const nodeWidth = getNodeWidth(d);
                const nodeHeight = getNodeHeight(d.depth);
                // 节点在svg group中的坐标（已经考虑了margin偏移）
                const nodeX = d.x;
                const nodeY = d.y;
                minX = Math.min(minX, nodeX - nodeWidth / 2);
                maxX = Math.max(maxX, nodeX + nodeWidth / 2);
                minY = Math.min(minY, nodeY);
                maxY = Math.max(maxY, nodeY + nodeHeight);
            });

            // 计算容器的实际大小
            const container = document.getElementById("tree-container");
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            // 计算内容的大小
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;

            // 如果内容为空或容器为空，不进行调整
            if (contentWidth <= 0 || contentHeight <= 0 || containerWidth <= 0 || containerHeight <= 0) {
                return;
            }

            // 计算缩放比例，留出一些边距（10%）
            let scale;
            if (initialScale !== null) {
                // 使用固定的初始缩放比例
                scale = initialScale;
            } else {
                // 自动计算适合的缩放比例
                const scaleX = (containerWidth * 0.9) / contentWidth;
                const scaleY = (containerHeight * 0.9) / contentHeight;
                scale = Math.min(scaleX, scaleY, 1); // 不放大，只缩小
            }

            // 计算内容的中心点（在svg group坐标系中）
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            // 计算需要平移的距离，使内容居中
            // 需要考虑margin偏移和缩放
            const translateX = (containerWidth / 2 - margin.left) - centerX * scale;
            const translateY = (containerHeight / 2 - margin.top) - centerY * scale;

            // 应用变换
            const transform = d3.zoomIdentity
                .translate(translateX, translateY)
                .scale(scale);

            currentTransform = transform;
            svgElement
                .transition()
                .duration(750)
                .call(zoom.transform, transform);
        }

        // 添加平移功能（支持缩放和平移）
        // 支持鼠标拖拽、触摸手势和触控板双指滑动

        // 将zoom绑定到SVG元素上
        svgElement.call(zoom);

        // 处理双指滑动（平移）- 当没有按住Ctrl/Cmd键时
        svgElement.on("wheel", function (event) {
            // 如果没有按住Ctrl/Cmd键，处理为平移（双指滑动）
            if (!event.ctrlKey && !event.metaKey) {
                event.preventDefault();
                event.stopPropagation();

                // 检测是否有平移值
                const hasDelta = Math.abs(event.deltaX) > 0 || Math.abs(event.deltaY) > 0;
                if (hasDelta) {
                    // 更新transform，实现平移
                    // 注意：deltaX和deltaY需要取反，因为SVG坐标系
                    currentTransform = currentTransform.translate(-event.deltaX, -event.deltaY);

                    // 直接应用transform，不通过zoom.transform，避免触发zoom事件
                    svg.attr("transform",
                        `translate(${margin.left + currentTransform.x},${margin.top + currentTransform.y}) scale(${currentTransform.k})`);
                }
            }
        }, { passive: false });

        // 添加触摸事件支持（移动设备）
        // 禁用默认触摸行为，使用D3的zoom处理触摸手势
        svgElement
            .style("touch-action", "none") // 禁用默认触摸行为，使用自定义手势
            .on("touchstart", function (event) {
                // 阻止默认行为，避免页面滚动
                // D3的zoom会自动处理单指和双指触摸
                if (event.touches.length >= 1) {
                    event.preventDefault();
                }
            })
            .on("touchmove", function (event) {
                // 阻止默认行为，让D3的zoom处理滑动
                // 支持单指和双指滑动
                if (event.touches.length >= 1) {
                    event.preventDefault();
                }
            })
            .on("touchend", function (event) {
                // 触摸结束时也阻止默认行为
                event.preventDefault();
            });
    </script>
</body>

</html>